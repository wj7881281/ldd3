##  8.1. The Real Story of kmalloc
kmalloc 分配引擎是一个功能强大的工具，并且由于与 malloc 相似而易于学习。该函数速度很快（除非它阻塞）并且不会清除它获得的内存；分配的区域仍然保留其以前的内容。分配的区域在物理内存中也是连续的。在接下来的几节中，我们将详细讨论 kmalloc，因此您可以将其与我们稍后讨论的内存分配技术进行比较。
> 除此之外，这意味着您应该显式清除可能暴露给用户空间或写入设备的任何内存；否则，您可能会泄露应保密的信息。

### 8.1.1. The Flags Argument
请记住 kmalloc 的原型是：
```c
#include <linux/slab.h>

void *kmalloc(size_t size, int flags);
```
kmalloc 的第一个参数是要分配的块的大小。第二个参数，分配标志，更有趣，因为它以多种方式控制 kmalloc 的行为。

最常用的标志 GFP_KERNEL 意味着分配（最终通过调用 __get_free_pages 在内部执行，这是 GFP_ 前缀的来源）代表在内核空间中运行的进程执行。换句话说，这意味着调用函数正在代表进程执行系统调用。使用 GFP_KERNEL 意味着 kmalloc 可以在内存不足的情况下调用时使当前进程进入睡眠状态，等待页面。因此，使用 GFP_KERNEL 分配内存的函数必须是可重入的，并且不能在原子上下文中运行。当当前进程休眠时，内核会采取适当的操作来定位一些空闲内存，方法是将缓冲区刷新到磁盘或从用户进程中换出内存。

GFP_KERNEL 并不总是正确的分配标志；有时 kmalloc 是从进程上下文外部调用的。例如，这种类型的调用可能发生在中断处理程序、微线程和内核定时器中。在这种情况下，当前进程不应进入睡眠状态，驱动程序应使用 GFP_ATOMIC 标志来代替。内核通常会尝试保留一些空闲页面以完成原子分配。当使用 GFP_ATOMIC 时，kmalloc 甚至可以使用最后一个空闲页。但是，如果最后一页不存在，则分配失败。

可以使用其他标志来代替 GFP_KERNEL 和 GFP_ATOMIC，或者除了 GFP_KERNEL 和 GFP_ATOMIC 之外，尽管这两个标志满足了设备驱动程序的大部分需求。所有标志都在 linux/gfp.h 中定义，各个标志都以双下划线为前缀，例如 _ _GFP_DMA。此外，还有代表常用标志组合的符号；

这些缺少前缀，有时称为分配优先级。后者包括：
__GFP_ATOMIC__

用于从中断处理程序和进程上下文之外的其他代码分配内存。从不睡觉。

__GFP_KERNEL__

内核内存的正常分配,会睡觉。

__GFP_USER__

用于为用户空间页面分配内存；它可能会睡觉。
__GFP_HIGHUSER__

与 GFP_USER 类似，但从高端内存分配（如果有）。高级内存将在下一小节中描述。

__GFP_NOIO__
__GFP_NOFS__

这些标志的功能类似于 GFP_KERNEL，但它们对内核可以执行哪些操作来满足请求添加了限制。GFP_NOFS 分配不允许执行任何文件系统调用，而 GFP_NOIO 根本不允许启动任何 I/O。它们主要用于文件系统和虚拟内存代码，其中可以允许分配休眠，但递归文件系统调用将是一个坏主意。

上面列出的分配标志可以通过以下任何标志中的 ORing 来扩充，这会改变分配的执行方式：

_ _GFP_DMA__

该标志请求在支持 DMA 的内存区域中进行分配。确切的含义取决于平台，并在以下部分中进行解释。

_ _GFP_HIGHMEM

该标志表明分配的内存可能位于高端内存。

_ _GFP_COLD

通常，内存分配器会尝试返回“缓存热”页面，即可能在处理器缓存中找到的页面。相反，该标志请求一个“冷”页面，该页面已经有一段时间没有被使用了。它对于分配用于 DMA 读取的页面非常有用，而处理器缓存中的页面则没有用处。有关如何分配 DMA 缓冲区的完整讨论，请参阅第 15 章。

_ _GFP_NOWARN

这个很少使用的标志可以防止内核在无法满足分配时发出警告（使用 printk）。

_ _GFP_HIGH

该标志标记一个高优先级请求，甚至允许消耗内核为紧急情况预留的最后一页内存。

_ _GFP_REPEAT
_ _GFP_NOFAIL
_ _GFP_NORETRY

这些标志修改分配器在难以满足分配时的行为方式。 _ _GFP_REPEAT 表示通过重复尝试“再努力一点”，但分配仍然可能失败。_ _GFP_NOFAIL 标志告诉分配器永远不会失败；它会根据需要努力工作以满足请求。强烈建议不要使用 _ _GFP_NOFAIL；可能永远不会有充分的理由在设备驱动程序中使用它。最后，_ _GFP_NORETRY 告诉分配器如果请求的内存不可用则立即放弃。

#### 8.1.1.1 Memory zones
_ _GFP_DMA 和 _ _GFP_HIGHMEM 都具有平台相关的角色，尽管它们的使用对所有平台都有效。

Linux内核最少知道三个记忆区： 支持 DMA 的内存、普通内存和高端内存。虽然分配通常发生在正常区域中，但设置刚才提到的任一位都需要从不同的区域分配内存。内核将了解这些内存区域的存在以满足不同的硬件和内核需求。有时，分配内存可能需要从不同的内存区域中进行选择。例如，某些硬件设备可能要求从DMA内存中分配内存，而不是从普通内存。内核需要具备处理这些要求的机制，以便不同的硬件和内核任务可以正常工作。

这个抽象层次的存在有助于让Linux内核更灵活地管理内存，并确保适应不同的硬件平台和需求。这些内存区域的划分和管理使Linux内核能够更好地适应各种计算环境。

支持 DMA 的内存是位于优先地址范围内的内存，外设可以在其中执行 DMA 访问。在大多数正常的平台上，所有内存都位于该区域中。在 x86 上，DMA 区域用于前 16 MB RAM，传统 ISA 设备可以在其中执行 DMA； PCI 设备没有这样的限制。

高内存是一种用于允许在 32 位平台上访问（相对）大量内存的机制。如果不首先设置特殊映射，则无法从内核直接访问此内存，并且通常更难使用。然而，如果您的驱动程序使用大量内存，那么如果它可以使用高内存，它将在大型系统上工作得更好。有关高级内存如何工作以及如何使用它的详细说明，请参阅第 15 章中的 1.8 节。

每当分配新页面来满足内存分配请求时，内核都会构建可在搜索中使用的区域列表。如果指定 _ _GFP_DMA，则仅搜索 DMA 区域：如果低地址处没有可用内存，则分配失败。如果不存在特殊标志，则搜索普通内存和 DMA 内存；如果设置了_ _GFP_HIGHMEM，则所有三个区域都用于搜索空闲页面。（但请注意，kmalloc 无法分配高端内存。）

在非均匀内存访问 (NUMA) 系统上情况更为复杂。作为一般规则，分配器尝试定位执行分配的处理器本地的内存，尽管有多种方法可以更改该行为。

内存区域背后的机制在 mm/page_alloc.c 中实现，而区域的初始化驻留在特定于平台的文件中，通常位于架构树内的 mm/init.c 中。我们将在第 15 章中重新讨论这些主题。


### 8.1.2 尺寸争论
内核管理系统的物理内存，该内存仅以页面大小的块形式提供。因此，kmalloc 看起来与典型的用户空间 malloc 实现有很大不同。简单的、面向堆的分配技术很快就会遇到麻烦；围绕页面边界工作会很困难。因此，内核使用特殊的面向页面的分配技术来充分利用系统的 RAM。

Linux 通过创建一组固定大小的内存对象池来处理内存分配。分配请求的处理方法是进入一个容纳足够大对象的池，并将整个内存块返回给请求者。内存管理方案相当复杂，设备驱动程序编写者通常对它的细节并不那么感兴趣。

不过，驱动程序开发人员应该记住的一件事是，内核只能分配某些预定义的、固定大小的字节数组。如果您请求任意数量的内存，您获得的内存可能会比您所要求的稍多一些，最多可达两倍。另外，程序员应该记住，kmalloc 可以处理的最小分配大小为 32 或 64 字节，具体取决于系统体系结构使用的页面大小。

kmalloc 可以分配的内存块的大小有上限。该限制因体系结构和内核配置选项而异。如果您的代码要完全可移植，则不能指望能够分配大于 128 KB 的任何内容。但是，如果您需要超过几千字节，则有比 kmalloc 更好的方法来获取内存，我们将在本章后面介绍。
