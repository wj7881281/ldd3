我们向您展示的下一个内存分配函数是 vmalloc，它在虚拟地址空间中分配连续的内存区域。尽管这些页面在物理内存中不是连续的（每个页面都是通过单独调用 alloc_page 来检索的），但内核将它们视为连续的地址范围。如果发生错误，malloc 返回 0（NULL 地址），否则，它返回一个指向大小至少为 size 的线性内存区域的指针。

我们在这里描述 vmalloc 是因为它是基本的 Linux 内存分配机制之一。然而，我们应该注意，在大多数情况下不鼓励使用 vmalloc。从 vmalloc 获得的内存使用效率稍低，并且在某些体系结构上，为 vmalloc 预留的地址空间量相对较小。如果将使用 vmalloc 的代码提交到内核中，则可能会受到冷遇。如果可能，您应该直接处理各个页面，而不是尝试使用 vmalloc 来解决问题。

也就是说，让我们看看 vmalloc 是如何工作的。该函数及其相关函数（ioremap，严格来说不是一个分配函数，将在本节后面讨论）的原型如下：
```c
#include <linux/vmalloc.h>

void *vmalloc(unsigned long size);
void vfree(void * addr);
void *ioremap(unsigned long offset, unsigned long size);
void iounmap(void * addr);
```
值得强调的是，kmalloc 和 _ get_free_pages 返回的内存地址也是虚拟地址。它们的实际值在用于寻址物理内存之前仍然由 MMU（内存管理单元，通常是 CPU 的一部分）进行处理。vmalloc 的不同之处并不在于它如何使用硬件，而在于内核如何执行分配任务。

> 实际上，一些体系结构将“虚拟”地址范围定义为保留用于寻址物理内存。当发生这种情况时，Linux 内核会利用该功能，并且内核和 _ _get_free_pages 地址都位于这些内存范围之一中。这种差异对于设备驱动程序和其他不直接涉及内存管理内核子系统的代码来说是透明的。

kmalloc 和 _ _get_free_pages 使用的（虚拟）地址范围具有到物理内存的一对一映射，可能会移动一个常量 PAGE_OFFSET 值；这些功能无需修改该地址范围的页面表。另一方面，vmalloc 和 ioremap 使用的地址范围是完全合成的，每次分配都会通过适当设置页表来构建（虚拟）内存区域。

通过比较分配函数返回的指针可以看出这种差异。在某些平台（例如 x86）上，vmalloc 返回的地址刚好超出 kmalloc 使用的地址。在其他平台（例如，MIPS、IA-64 和 x86_64）上，它们属于完全不同的地址范围。可用于 vmalloc 的地址范围为 VMALLOC_START 到 VMALLOC_END。这两个符号都在 asm/pgtable.h 中定义。

由 vmalloc 分配的地址不能在微处理器外部使用，因为它们仅在处理器的 MMU 之上才有意义。当驱动程序需要真实的物理地址（例如DMA地址，由外围硬件用来驱动系统总线）时，就不能轻易使用vmalloc。调用 vmalloc 的正确时机是为仅存在于软件中的大型顺序缓冲区分配内存时。需要注意的是，vmalloc 比 __get_free_pages 具有更多的开销，因为它必须检索内存并构建页表。因此，调用 vmalloc 只分配一页是没有意义的。

内核中使用 vmalloc 的函数的一个示例是 create_module 系统调用，它使用 vmalloc 为正在创建的模块获取空间。随后使用 copy_from_user 将模块的代码和数据复制到分配的空间。通过这种方式，模块看起来被加载到连续的内存中。您可以通过查看 /proc/kallsyms 来验证模块导出的内核符号与内核本身导出的符号位于不同的内存范围中。

vmalloc 分配的内存由 vfree 释放，与 kfree 释放 kmalloc 分配的内存的方式相同。

与vmalloc一样，ioremap构建新的页表；但是，与Vmalloc不同，它实际上并未分配任何内存。ioremap的返回值是一个特殊的虚拟地址，可以用来访问指定的物理地址范围；获得的虚拟地址最终通过调用iounmap释放。

