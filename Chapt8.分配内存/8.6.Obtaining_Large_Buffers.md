正如我们在前面几节中提到的，大型连续内存缓冲区的分配很容易失败。随着时间的推移，系统内存会产生碎片，并且很可能真正大的内存区域根本不可用。由于通常有多种方法可以在没有巨大缓冲区的情况下完成工作，因此内核开发人员并没有高度重视使大型分配工作。在尝试获取大内存区域之前，您应该真正考虑替代方案。到目前为止，执行大型 I/O 操作的最佳方法是通过分散/聚集操作，我们将在第 15 章中讨论。

### 8.6.1 在启动时获取专用缓冲区
> 在系统启动时执行内存分配的方法，这允许检索连续的内存页。这种方法被建议作为一种规避 _ _get_free_pages 函数强加的限制的方式，这些限制包括内存大小的最大允许值以及可用于分配的大小的限制。这种技术可能在需要比函数在正常操作期间提供的更大或更灵活的内存分配时有用。
如果您确实需要物理连续内存的巨大缓冲区，最好的方法通常是通过在启动时请求内存来分配它。启动时分配是检索连续内存页面的唯一方法，同时绕过 _ _get_free_pages 对缓冲区大小施加的限制，无论是在最大允许大小还是有限的大小选择方面。在启动时分配内存是一种“肮脏”技术，因为它通过保留私有内存池来绕过所有内存管理策略。这种技术不优雅且不灵活，但也是最不容易失败的。不用说，模块不能在启动时分配内存；只有直接链接到内核的驱动程序才能做到这一点。

启动时分配的一个值得注意的问题是，它对于普通用户来说不是一个可行的选择，因为这种机制仅适用于内核映像中链接的代码。使用这种分配的设备驱动程序只能通过重建内核并重新启动计算机来安装或替换。

当内核启动时，它可以访问系统中所有可用的物理内存。然后，它通过调用子系统的初始化函数来初始化每个子系统，从而允许初始化代码通过减少正常系统操作剩余的 RAM 量来分配内存缓冲区供私人使用。

引导时内存分配是通过调用以下函数之一来执行的：
```c
#include <linux/bootmem.h>
void *alloc_bootmem(unsigned long size);
void *alloc_bootmem_low(unsigned long size);
void *alloc_bootmem_pages(unsigned long size);
void *alloc_bootmem_low_pages(unsigned long size);
```

这些函数分配整个页面（如果它们以 _pages 结尾）或非页面对齐的内存区域。分配的内存可能是高内存，除非使用 _low 版本之一。如果您为设备驱动程序分配此缓冲区，您可能希望将其用于 DMA 操作，而这对于高内存来说并不总是可行；因此，您可能想使用 _low 变体之一。

很少会释放启动时分配的内存；如果您想要的话，几乎可以肯定您以后将无法取回它。然而，有一个接口可以释放该内存：
```c
void free_bootmem(unsigned long addr, unsigned long size);
```

请注意，以这种方式释放的部分页面不会返回到系统，但是，如果您使用此技术，您可能已经分配了相当数量的整个页面。

如果必须使用引导时分配，则需要将驱动程序直接链接到内核中。有关如何完成此操作的更多信息，请参阅 Documentation/kbuild 下内核源代码中的文件。
