## 11.2. 为数据项分配显式大小
有时内核代码需要特定大小的数据项，可能是为了匹配预定义的二进制结构，[1] 与用户空间通信，或者通过插入“填充”字段来对齐结构内的数据（但有关对齐问题的信息，请参阅第 11.4.4 节）。
> [1] 在读取分区表、执行二进制文件或解码网络数据包时，会发生这种情况。

内核提供以下数据类型，供您在需要了解数据大小时使用。所有类型都在 asm/types.h 中声明，而 linux/types.h 又包含该类型：
```
u8;   /* unsigned byte (8 bits) */
u16;  /* unsigned word (16 bits) */
u32;  /* unsigned 32-bit value */
u64;  /* unsigned 64-bit value */
```
相应的有符号类型存在，但很少需要;如果需要，只需在名称中将 u 替换为 s。如果用户空间程序需要使用这些类型，它可以在名称前面加上双下划线：_ _u8 和其他类型是独立于 _ _KERNEL_ _ 定义的。例如，如果驱动程序需要通过 ioctl 与在用户空间中运行的程序交换二进制结构，则头文件应将结构中的 32 位字段声明为 _ _u32。

重要的是要记住，这些类型是特定于 Linux 的，使用它们会阻碍将软件移植到其他 Unix 风格。具有最新编译器的系统支持 C99 标准类型，例如 uint8_t 和 uint32_t;如果可移植性是一个问题，则可以使用这些类型来支持特定于 Linux 的变体。

您可能还会注意到，有时内核对维度与体系结构无关的项使用常规类型，例如 unsigned int。这样做通常是为了向后兼容。在版本 1.1.67 中引入 u32 和 friends 时，开发人员无法将现有数据结构更改为新类型，因为当结构字段与分配给它的值之间存在类型不匹配时，编译器会发出警告。在版本 1.1.67 中引入 u32 和 friends 时，开发人员无法将现有数据结构更改为新类型，因为当结构字段与分配给它的值之间存在类型不匹配时，编译器会发出警告。
> 事实上，编译器会发出类型不一致的信号，即使这两种类型只是同一对象的不同名称，例如 PC 上的 unsigned long 和 u32。