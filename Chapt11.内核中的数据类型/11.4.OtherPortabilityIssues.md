## 11.4. 其他可移植性问题
除了数据类型之外，如果希望驱动程序可以跨 Linux 平台移植，在编写驱动程序时还需要记住其他一些软件问题。

一般规则是对显式常量值持怀疑态度。通常，代码已使用预处理器宏进行参数化。本节列出了最重要的可移植性问题。每当遇到其他已参数化的值时，都可以在头文件和随官方内核分发的设备驱动程序中找到提示。

### 11.4.1. 时间间隔
在处理时间间隔时，不要假设每秒有 1000 个 jiffies。尽管目前 i386 架构确实如此，但并非每个 Linux 平台都以这种速度运行。如果你使用 HZ 值（就像有些人一样），即使对于 x86 来说，这个假设也可能是错误的，没有人知道未来的内核会发生什么。每当您使用 jiffies 计算时间间隔时，请使用 HZ（每秒计时器中断次数）来缩放时间。例如，要检查半秒的超时，请将运行时间与 HZ/2 进行比较。更一般地说，对应于毫秒的 jiffies 数始终为 msec*HZ/1000。

### 11.4.2. 页面大小
使用内存玩游戏时，请记住内存页是 PAGE_SIZE 字节，而不是 4 KB。假设页面大小为 4 KB，并且对该值进行硬编码是 PC 程序员的常见错误，相反，支持的平台显示的页面大小从 4 KB 到 64 KB，有时它们在同一平台的不同实现之间有所不同。相关的宏是 PAGE_SIZE 和 PAGE_SHIFT。后者包含移动地址以获取其页码的位数（也就是2的多少次方）。对于 4 KB 或更大的页面，该数字当前为 12 或更大。宏在 asm/page.h 中定义;如果用户空间程序需要信息，可以使用 GetPageSize 库函数。

让我们看一个不平凡的情况。如果驱动程序需要 16 KB 的临时数据，则不应指定 2 到 get_free_pages 的顺序。   您需要一个便携式解决方案。幸运的是，这样的解决方案是由内核开发人员编写的，称为get_order：
```c
#include <asm/page.h>
int order = get_order(16*1024);
buf = get_free_pages(GFP_KERNEL, order);
```
请记住，get_order的论点必须是 2 的幂。
### 11.4.3. 字节顺序
注意不要对字节排序做出假设。虽然 PC 首先存储低字节值（小端优先，因此是小端），但一些高级平台以另一种方式工作（大端）。只要有可能，你的代码就应该被编写成这样，这样它就不关心它所操作的数据中的字节顺序。但是，有时驱动程序需要从单个字节中生成整数或执行相反的操作，或者它必须与需要特定顺序的设备通信。

包含文件 asm/byteorder.h 定义 _ _BIG_ENDIAN 或 _ _LITTLE_ENDIAN，具体取决于处理器的字节顺序。在处理字节排序问题时，你可以编写一堆 #ifdef _ _LITTLE_ENDIAN条件，但有更好的方法。Linux 内核定义了一组宏，用于处理处理器的字节顺序与需要以特定字节顺序存储或加载的数据之间的转换。例如：
```c
u32 cpu_to_le32 (u32);
u32 le32_to_cpu (u32);
```
这两个宏将值从 CPU 使用的任何值转换为无符号、小端序、32 位数量并返回。无论您的 CPU 是大端还是小端，无论它是否是 32 位处理器，它们都可以工作。在没有工作要做的情况下，他们原封不动地返回他们的论点。使用这些宏可以轻松编写可移植代码，而无需使用大量条件编译构造。

有几十个类似的例程;您可以在 linux/byteorder/big_endian.h 和 linux/byteorder/little_endian.h 中查看完整列表。过了一会儿，这种模式就不难理解了。be64_to_cpu将无符号的 big-endian 64 位值转换为内部 CPU 表示形式。相反，le16_to_cpus处理有符号的 little-endian 16 位数量。在处理指针时，还可以使用cpu_to_le32p等函数，这些函数采用指向要转换的值的指针，而不是值本身。有关其余部分，请参阅包含文件。

### 11.4.4. 数据对齐
编写可移植代码时，最后一个值得考虑的问题是如何访问未对齐的数据，例如，如何读取存储在不是 4 个字节倍数的地址上的 4 字节值。i386 用户经常访问未对齐的数据项，但并非所有架构都允许这样做。许多现代架构每次程序尝试未对齐的数据传输时都会生成异常;数据传输由异常处理程序处理，性能损失很大。如果需要访问未对齐的数据，则应使用以下宏：
```c
#include <asm/unaligned.h>
get_unaligned(ptr);
put_unaligned(val, ptr);
```
这些宏是无类型的，适用于每个数据项，无论其长度为 1、2、4 还是 8 个字节。它们由任何内核版本定义。

与一致性相关的另一个问题是数据结构跨平台的可移植性。相同的数据结构（在 C 语言源文件中定义）可以在不同的平台上以不同的方式编译。编译器根据不同平台的约定安排要对齐的结构字段。

为了为可跨体系结构移动的数据项编写数据结构，除了对特定字节序进行标准化外，还应始终强制执行数据项的自然对齐。自然对齐意味着将数据项存储在其大小的倍数的地址中（例如，8 字节项的地址倍数为 8）。若要强制执行自然对齐，同时防止编译器以不可预测的方式排列字段，应使用避免在数据结构中留下漏洞的填充字段。

为了显示编译器如何强制对齐，dataalign 程序分布在示例代码的 misc-progs 目录中，等效的 kdataalign 模块是 misc-modules 的一部分。这是程序在多个平台上的输出和模块在SPARC64上的输出：
```
arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
i386            1     2     4     4     4     4        1   2   4   4
i686            1     2     4     4     4     4        1   2   4   4
alpha           1     2     4     8     8     8        1   2   4   8
armv4l          1     2     4     4     4     4        1   2   4   4
ia64            1     2     4     8     8     8        1   2   4   8
mips            1     2     4     4     4     8        1   2   4   8
ppc             1     2     4     4     4     8        1   2   4   8
sparc           1     2     4     4     4     8        1   2   4   8
sparc64         1     2     4     4     4     8        1   2   4   8
x86_64          1     2     4     8     8     8        1   2   4   8

kernel: arch  Align: char short int long  ptr long-long u8 u16 u32 u64
kernel: sparc64        1    2    4    8    8     8       1   2   4   8
```
有趣的是，并非所有平台都在 64 位边界上对齐 64 位值，因此您需要填充字段来强制对齐并确保可移植性。

最后，请注意，编译器可能会悄悄地将填充插入到结构本身中，以确保每个字段都对齐，以便在目标处理器上获得良好的性能。如果要定义旨在与设备预期的结构匹配的结构，则此自动填充可能会阻止您的尝试。解决这个问题的方法是告诉编译器结构必须“打包”，不添加填充物。例如，内核头文件 linux/edd.h 定义了用于与 x86 BIOS 接口的几种数据结构，它包括以下定义：
```c
struct {
        u16 id;
        u64 lun;
        u16 reserved1;
        u32 reserved2;
} _ _attribute_ _ ((packed)) scsi;
```
如果没有 _ _attribute_ _ （（packed）），如果我们在 64 位平台上编译结构，则 lun 字段前面将有两个填充字节或六个填充字节。

### 11.4.5. 指针和错误值
许多内部内核函数将指针值返回给调用方。其中许多函数也可能失败。在大多数情况下，失败是通过返回 NULL 指针值来指示的。这种技术有效，但它无法传达问题的确切性质。某些接口确实需要返回实际的错误代码，以便调用方可以根据实际出错的原因做出正确的决定。

许多内核接口通过在指针值中对错误代码进行编码来返回此信息。必须谨慎使用此类函数，因为它们的返回值不能简单地与 NULL 进行比较。为了帮助创建和使用这种接口，提供了一小部分函数（在 linux/err.h 中）。

返回指针类型的函数可以返回错误值，如下所示：
```c
void *ERR_PTR(long error);
```
其中 error 是通常的负错误代码。调用方可以使用IS_ERR来测试返回的指针是否为错误代码：
```c
long IS_ERR(const void *ptr);
```
如果需要实际的错误代码，可以使用以下命令提取：
```c
long PTR_ERR(const void *ptr);
```
应仅对IS_ERR返回 true 值的值使用 PTR_ERR;任何其他值都是有效的指针。


