## 11.3. 特定于接口的类型
内核中一些常用的数据类型有自己的 typedef 语句，从而防止了任何可移植性问题。例如，进程标识符 （pid） 通常为 pid_t而不是 int。使用 pid_t 可以掩盖实际数据类型中可能存在的任何差异。我们使用特定于表达式接口来引用由库定义的类型，以便为特定数据结构提供接口。

请注意，最近定义的特定于接口的新类型相对较少。typedef 语句的使用在许多内核开发人员中已经失宠，他们宁愿看到代码中直接使用的真实类型信息，而不是隐藏在用户定义的类型后面。然而，许多较旧的特定于接口的类型仍保留在内核中，并且它们不会很快消失。

即使没有定义特定于接口的类型，以与内核其余部分一致的方式使用正确的数据类型也始终很重要。例如，jiffy 计数始终是无符号的 long，与其实际大小无关，因此在处理 jiffies 时应始终使用 unsigned long 类型。在本节中，我们将重点介绍_t类型的使用。

许多_t类型在 linux/types.h 中定义，但该列表很少有用。当您需要特定类型时，您会在需要调用的函数的原型或您使用的数据结构中找到它。

每当驱动程序使用需要此类“自定义”类型的函数并且你不遵循约定时，编译器就会发出警告;如果使用 -Wall 编译器标志并小心删除所有警告，则可以确信代码是可移植的。

_t数据项的主要问题是，当您需要打印它们时，选择正确的 printk 或 printf 格式并不总是那么容易，并且您在一种体系结构上解决的警告会在另一种体系结构上重新出现。例如，您将如何打印一个size_t，在某些平台上是无符号的 long，而在其他一些平台上是无符号的 int？

每当需要打印一些特定于接口的数据时，最好的方法是将值转换为最大可能的类型（通常是 long 或 unsigned long），然后通过相应的格式打印它。这种调整不会生成错误或警告，因为格式与类型匹配，并且不会因为强制转换是 null 操作或将项目扩展到更大的数据类型而丢失数据位。

在实践中，我们讨论的数据项通常不需要打印，因此该问题仅适用于调试消息。大多数情况下，代码只需要存储和比较特定于接口的类型，以及将它们作为参数传递给库或内核函数。

尽管_t类型是大多数情况下的正确解决方案，但有时并不存在正确的类型。对于一些尚未清理的旧接口，会发生这种情况。

我们在内核头文件中发现的一个模棱两可的点是 I/O 函数的数据类型，它是松散定义的（参见第 9 章的第 9.2.6 节）。松散类型主要是由于历史原因而存在的，但在编写代码时可能会产生问题。例如，通过将参数交换为 outb 等函数可能会遇到麻烦;如果存在port_t类型，编译器将发现此类错误。