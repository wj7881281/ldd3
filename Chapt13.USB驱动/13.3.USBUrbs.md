## 13.3. USB Urbs
Linux 内核中的 USB 代码使用 urb（USB 请求块）与所有 USB 设备进行通信。该请求块用 struct urb 结构描述，可以在 include/linux/usb.h 文件中找到。

urb 用于以异步方式向特定 USB 设备上的特定 USB 端点发送数据或从特定 USB 端点接收数据。它的使用方式很像文件系统异步 I/O 代码中使用的 kiocb 结构或网络代码中使用的 skbuff 结构。USB 设备驱动程序可以为单个端点分配多个 urb，也可以为许多不同的端点重用单个 urb，具体取决于驱动程序的需要。设备中的每个端点都可以处理 urb 队列，以便在队列为空之前可以将多个 urb 发送到同一端点。urb 的典型生命周期如下：

- 由 USB 设备驱动程序创建。
- 分配给特定 USB 设备的特定端点。
- 由USB设备驱动程序提交给USB核心。
- 由USB核心提交给指定设备的特定USB主机控制器驱动程序。
- 由 USB 主机控制器驱动程序处理，该驱动程序向设备进行 USB 传输。
- 当urb完成时，USB主机控制器驱动程序通知USB设备驱动程序。

Urb 也可以随时由提交 urb 的驱动程序取消，或者在设备从系统中删除时由 USB 核心取消。 urb 是动态创建的，并包含一个内部引用计数，使它们能够在 urb 的最后一个用户释放它时自动释放。

本章中描述的处理 urb 的过程很有用，因为它允许流式传输和其他复杂的重叠通信，从而允许驱动程序实现尽可能高的数据传输速度。但是，如果您只想发送单独的批量或控制消息并且不关心数据吞吐率，则可以使用不太麻烦的过程。 （参见第 13.5 节。）

### 13.3.1. struct urb
对 USB 设备驱动程序重要的 struct urb 结构的字段是：
```c
struct usb_device *dev
```
指向该 urb 发送到的 struct usb_device 的指针。在 urb 被发送到 USB 核心之前，该变量必须由 USB 驱动程序初始化。
```c
unsigned int pipe
```
该 urb 要发送到的特定 struct usb_device 的端点信息。在 urb 被发送到 USB 核心之前，该变量必须由 USB 驱动程序初始化。

为了设置此结构的字段，驱动程序根据交通方向适当使用以下函数。请注意，每个端点只能属于一种类型。
```c
unsigned int usb_sndctrlpipe(struct usb_device *dev, unsigned int endpoint)
```
为具有指定端点编号的指定 USB 设备指定控制 OUT 端点。
```c
unsigned int usb_rcvctrlpipe(struct usb_device *dev, unsigned int
endpoint)
```
为具有指定端点编号的指定 USB 设备指定控制 IN 端点。
```c
unsigned int usb_sndbulkpipe(struct usb_device *dev, unsigned int
endpoint)
```
为具有指定端点编号的指定 USB 设备指定批量 OUT 端点。
```c
unsigned int usb_rcvbulkpipe(struct usb_device *dev, unsigned int
endpoint)
```
为具有指定端点编号的指定 USB 设备指定批量 IN 端点。
```c
unsigned int usb_sndintpipe(struct usb_device *dev, unsigned int endpoint)
```
为具有指定端点号的指定 USB 设备指定中断 OUT 端点。
```c
unsigned int usb_rcvintpipe(struct usb_device *dev, unsigned int endpoint)
```
为具有指定端点号的指定 USB 设备指定中断 IN 端点。
```c
unsigned int usb_sndisocpipe(struct usb_device *dev, unsigned int
endpoint)
```
为具有指定端点号的指定 USB 设备指定同步 OUT 端点。
```c
unsigned int usb_rcvisocpipe(struct usb_device *dev, unsigned int
endpoint)
```
为具有指定端点号的指定 USB 设备指定同步 IN 端点。

*****************************
```c
unsigned int transfer_flags
```
该变量可以设置为许多不同的位值，具体取决于 USB 驱动程序希望 urb 发生什么情况。可用值为：

__URB_SHORT_NOT_OK__ 设置后，它指定 USB 核心应将 IN 端点上可能发生的任何短读取视为错误。该值仅适用于要从 USB 设备读取的 urb，不适用于写入 urb。

__URB_ISO_ASAP__ 如果 urb 是同步的，如果驱动程序希望在带宽利用率允许的情况下调度 urb，则可以设置该位，并在此时设置 urb 中的 start_frame 变量。如果未为等时 urb 设置该位，则驱动程序必须指定 start_frame 值，并且如果此时传输无法启动，则必须能够正确恢复。有关更多信息，请参阅即将到来的有关等时 urb 的部分。

__URB_NO_TRANSFER_DMA_MAP__ 当 urb 包含要传输的 DMA 缓冲区时应设置。USB 内核使用 TRansfer_dma 变量指向的缓冲区，而不是 Transfer_buffer 变量指向的缓冲区。

__URB_NO_SETUP_DMA_MAP__  与 URB_NO_TRANSFER_DMA_MAP 位一样，此位用于已设置 DMA 缓冲区的控制 urb。如果设置了，USB 内核将使用 setup_dma 变量指向的缓冲区，而不是 setup_packet 变量。

__URB_ASYNC_UNLINK__ 如果设置，则对该 urb 的 usb_unlink_urb 调用几乎立即返回，并且该 urb 在后台取消链接。否则，该函数将等到 urb 完全取消链接并完成后再返回。请小心使用该位，因为它会使同步问题很难调试。

__URB_NO_FSBR__  仅由 UHCI USB 主机控制器驱动程序使用，并告诉它不要尝试执行前端总线回收逻辑。通常不应设置该位，因为具有 UHCI 主机控制器的机器会产生大量 CPU 开销，并且 PCI 总线在等待设置该位的 urb 时处于饱和状态。

__URB_ZERO_PACKET__ 如果设置，当数据与端点数据包边界对齐时，批量输出 urb 将通过发送不包含数据的短数据包来完成。一些损坏的 USB 设备（例如许多 USB 转 IR 设备）需要这样做才能正常工作。

__URB_NO_INTERRUPT__ 如果设置，当 urb 完成时，硬件可能不会生成中断。应谨慎使用该位，并且仅在将多个 urb 排队到同一端点时使用。USB 核心功能使用它来进行 DMA 缓冲区传输。

__void *transfer_buffer__ 指向向设备发送数据（对于 OUT urb）或从设备接收数据（对于 IN urb）时使用的缓冲区的指针。为了使主机控制器正确访问此缓冲区，必须通过调用 kmalloc 创建它，而不是在堆栈上或静态地创建它。对于控制端点，该缓冲区用于传输的数据阶段。

__dma_addr_t transfer_dma__ 用于使用 DMA 将数据传输到 USB 设备的缓冲区。

__int transfer_buffer_length__ 由transfer_buffer 或transfer_dma 变量指向的缓冲区的长度（因为一个urb 只能使用一个）。如果该值为 0，则 USB 内核不会使用两个传输缓冲区。

