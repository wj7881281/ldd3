我们在本章中研究的最后一个设备模型概念是类。类是设备的高级视图，它抽象出低级实现细节。驱动程序可能会看到 SCSI 磁盘或 ATA 磁盘，但在类级别，它们都只是磁盘。类允许用户空间根据设备的功能（而不是设备的连接方式或工作方式）来使用设备。

几乎所有类都显示在 /sys/class 下的 sysfs 中。因此，例如，无论接口类型如何，所有网络接口都可以在 /sys/class/net 下找到。输入设备可以在/sys/class/input中找到，串行设备可以在/sys/class/tty中找到。一个例外是块设备，由于历史原因，可以在 /sys/block 下找到它。

类成员资格通常由高级代码处理，不需要驱动程序的显式支持。当 sbull 驱动程序（参见第 16 章）创建虚拟磁盘设备时，它会自动出现在 /sys/block 中。snull 网络驱动程序（参见第 17 章）不必为其在 /sys/class/net 中表示的接口执行任何特殊操作。然而，有时驱动程序最终会直接处理类。

在许多情况下，类子系统是将信息导出到用户空间的最佳方式。当子系统创建一个类时，它完全拥有该类，因此无需担心哪个模块拥有在那里找到的属性。花费很少的时间在 sysfs 中更面向硬件的部分中徘徊，就会意识到它对于直接浏览来说可能是一个不友好的地方。用户更乐意在 /sys/class/some-widget 中查找信息，而不是在 /sys/devices/pci0000:00/0000:00:10.0/usb2/2-0:1.0 下查找信息。

驱动程序核心导出两个不同的接口来管理类。class_simple 例程旨在尽可能轻松地向系统添加新类；它们的主要目的通常是公开包含设备编号的属性，以实现设备节点的自动创建。常规类接口更复杂，但也提供更多功能。我们从简单的版本开始。

### 14.5.1  class_simple 接口
class_simple 接口的目的是非常易于使用，以至于没有人有任何借口不至少导出包含设备分配编号的属性。使用此接口只需几个函数调用，几乎不需要与 Linux 设备模型相关的常用样板。

第一步是创建类本身。这是通过调用 class_simple_create 来完成的：

```c
struct class_simple *class_simple_create(struct module *owner, char *name);
```
该函数创建一个具有给定名称的类。当然，该操作可能会失败，因此在继续之前应始终检查返回值（使用 IS_ERR，如第 11 章 1.8 节所述）。

一个简单的类可以通过以下方式销毁：
```c
void class_simple_destroy(struct class_simple *cs);
```
创建简单类的真正目的是向其中添加设备；该任务是通过以下方式实现的：
```c
struct class_device *class_simple_device_add(struct class_simple *cs,
                                             dev_t devnum,
                                             struct device *device,
                                             const char *fmt, ...);
```
这里，cs是之前创建的简单类，devnum是分配的设备号，device是表示该设备的struct device，其余参数是printk样式的格式字符串和用于创建设备名称的参数。此调用向包含一个属性 dev 的类添加一个条目，该属性保存设备号。如果设备参数不为 NULL，则符号链接（称为 device）指向 /sys/devices 下的设备条目。

可以向设备条目添加其他属性。这只是使用 class_device_create_file 的问题，我们将在下一节中与完整类子系统的其余部分讨论它。

当设备来来去去时，类会生成热插拔事件。如果您的驱动程序需要向用户空间事件处理程序的环境添加变量，它可以使用以下命令设置热插拔回调：
```c
int class_simple_set_hotplug(struct class_simple *cs, 
                             int (*hotplug)(struct class_device *dev, 
                                            char **envp, int num_envp, 
                                            char *buffer, int buffer_size));

```
当您的设备消失时，应使用以下命令删除类条目：
```c
void class_simple_device_remove(dev_t dev);
```
注意，这里不需要class_simple_device_add返回的class_device结构体；设备编号（当然应该是唯一的）就足够了。

### 14.5.2.完整的类接口
