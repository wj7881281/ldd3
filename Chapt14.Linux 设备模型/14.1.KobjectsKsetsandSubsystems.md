### 14.1. Kobjects, Ksets, and Subsystems
kobject 是将设备模型结合在一起的基本结构。它最初被设想为一个简单的参考计数器，但随着时间的推移，它的职责不断增长，它的字段也不断增长。struct kobject 及其支持代码处理的任务现在包括：

**Reference counting of objects** :通常，当创建内核对象时，无法知道它会存在多久。跟踪此类对象生命周期的一种方法是通过引用计数。当内核中没有代码保存对给定对象的引用时，该对象已完成其使用寿命并且可以被删除。

**Sysfs representation** ：sysfs 中显示的每个对象在其下面都有一个 kobject，它与内核交互以创建其可见表示。

**Data structure glue** ：整个设备模型是一个极其复杂的数据结构，由多个层次结构组成，它们之间有许多链接。 kobject 实现了这个结构并将其组合在一起。

**Hotplug event handling** ：kobject 子系统处理事件的生成，通知用户空间有关系统上硬件的情况。


从前面的列表中，人们可能会得出这样的结论：kobject 是一种复杂的结构。一个是对的。然而，通过一次查看一件作品，可以理解这种结构及其工作原理。

### 14.1.1.对象基础知识
kobject 的类型为 struct kobject；它在 <linux/kobject.h> 中定义。该文件还包括与 kobject 相关的许多其他结构的声明，当然还有一长串用于操作它们的函数。

#### 14.1.1.1 嵌入kobject
在我们深入了解细节之前，值得花一些时间来了解 kobject 的使用方式。如果您回顾 kobject 处理的函数列表，您会发现它们都是代表其他对象执行的服务。换句话说，kobject 本身没有什么意义。它的存在只是为了将更高级别的对象绑定到设备模型中。

因此，内核代码很少（甚至未知）创建独立的 kobject；相反，kobject 用于控制对更大的、特定于域的对象的访问。为此，kobject 被嵌入到其他结构中。如果您习惯于用面向对象的术语来思考事物，那么 kobject 可以被视为一个顶级的抽象类，其他类都派生自该类。kobject 实现了一组功能，这些功能本身并不是特别有用，但在其他对象中却很有用。C 语言不允许直接表达继承，因此必须使用其他技术（例如将一种结构嵌入另一种结构）。

作为一个例子，让我们回顾一下我们在第 3 章中遇到的 struct cdev。该结构在 2.6.10 内核中找到，如下所示：

```c
struct cdev {
    struct kobject kobj;
    struct module *owner;
    struct file_operations *ops;
    struct list_head list;
    dev_t dev;
    unsigned int count;
};
```
正如我们所看到的，cdev 结构中嵌入了一个 kobject。如果您有这些结构之一，则只需使用 kobj 字段即可找到其嵌入的 kobject。然而，使用 kobject 的代码通常会遇到相反的问题：给定一个 struct kobject 指针，指向包含结构的指针是什么？您应该避免使用技巧（例如假设 kobject 位于结构的开头），而是使用 container_of 宏（在第 3.5.1 节中介绍）。因此，将指针转换为嵌入在 struct cdev 中的名为 kp 的 struct kobject 的方法是：
```c
struct cdev *device = container_of(kp, struct cdev, kobj);
```
程序员经常定义一个简单的宏来将 kobject 指针“反向转换”到包含类型。

#### 14.1.1.2 Kobject初始化
kobject 的关键功能之一是充当它所嵌入的对象的引用计数器。只要对该对象的引用存在，该对象（以及支持它的代码）就必须继续存在。用于操作 kobject 引用计数的低级函数是：
```c
struct kobject *kobject_get(struct kobject *kobj);
void kobject_put(struct kobject *kobj);
```
成功调用 kobject_get 会增加 kobject 的引用计数器并返回指向 kobject 的指针。然而，如果 kobject 已经在被销毁的过程中，则操作失败，并且 kobject_get 返回 NULL。必须始终测试此返回值，否则可能会导致不愉快的竞争条件。

当释放引用时，对 kobject_put 的调用会减少引用计数，并可能释放该对象。请记住，kobject_init 将引用计数设置为 1；因此，当您创建一个 kobject 时，您应该确保当不再需要该初始引用时进行相应的 kobject_put 调用。

请注意，在许多情况下，kobject 本身的引用计数可能不足以防止竞争条件。例如，kobject（及其包含结构）的存在很可能需要创建该 kobject 的模块的持续存在。当 kobject 仍在传递时卸载该模块是行不通的。这就是为什么我们上面看到的 cdev 结构包含一个 struct module 指针。struct cdev 的引用计数实现如下：
```c
struct kobject *cdev_get(struct cdev *p)
{
    struct module *owner = p->owner;
    struct kobject *kobj;

    if (owner && !try_module_get(owner))
        return NULL;
    kobj = kobject_get(&p->kobj);
    if (!kobj)
        module_put(owner);
    return kobj;
}
```
创建对 cdev 结构的引用还需要创建对拥有它的模块的引用。因此 cdev_get 使用 try_module_get 尝试增加该模块的使用计数。如果该操作成功，kobject_get 也会用于增加 kobject 的引用计数。当然，该操作可能会失败，因此代码会检查 kobject_get 的返回值，并在出现问题时释放其对模块的引用。

#### 14.1.1.4 释放函数和kobject类型
讨论中仍然遗漏的一件重要事情是当 kobject 的引用计数达到 0 时会发生什么。创建 kobject 的代码通常不知道什么时候会发生；如果确实如此，那么首先使用引用计数就没有意义了。当引入 sysfs 时，即使是可预测的对象生命周期也会变得更加复杂；用户空间程序可以在任意时间段内保留对 kobject 的引用（通过保持其关联的 sysfs 文件之一打开）。

最终结果是，受 kobject 保护的结构无法在驱动程序生命周期中的任何单个、可预测点处释放，但在必须准备好在 kobject 的引用计数变为 0 的任何时刻运行的代码中释放。最终结果是，受 kobject 保护的结构无法在驱动程序生命周期中的任何单个、可预测点处释放，但在必须准备好在 kobject 的引用计数变为 0 的任何时刻运行的代码中释放。引用计数不受创建 kobject 的代码的直接控制。因此，只要对其 kobject 之一的最后一个引用消失，就必须异步通知该代码。

该通知是通过 kobject 的 release 方法完成的。通常，该方法的形式如下：
```c
void my_object_release(struct kobject *kobj)
{
    struct my_object *mine = container_of(kobj, struct my_object, kobj);

    /* Perform any additional cleanup on this object, then... */
    kfree(mine);
}
```
重要的一点怎么强调都不为过：每个 kobject 都必须有一个release方法，并且 kobject 必须持续存在（处于一致的状态）直到该方法被调用。如果不满足这些约束，则代码就有缺陷。它存在在对象仍在使用时释放该对象的风险，或者在返回最后一个引用后无法释放该对象的风险。

有趣的是，release方法并不存储在kobject本身中；相反，它与包含 kobject 的结构的类型相关联。该类型通过 struct kobj_type 类型的结构进行跟踪，通常简称为“ktype”。该结构如下所示：
```c
struct kobj_type {
    void (*release)(struct kobject *);
    struct sysfs_ops *sysfs_ops;
    struct attribute **default_attrs;
};
```
当然，struct kobj_type 中的release字段是指向该类型kobject的release方法的指针。我们将在本章稍后讨论其他两个字段（sysfs_ops 和 default_attrs）。

每个 kobject 都需要有一个关联的 kobj_type 结构。令人困惑的是，可以在两个不同的地方找到指向该结构的指针。kobject 结构本身包含一个可以包含此指针的字段（称为 ktype）。然而，如果该 kobject 是 kset 的成员，则 kobj_type 指针将由该 kset 提供。 （我们将在下一节中讨论 kset。）同时，宏：

```c
struct kobj_type *get_ktype(struct kobject *kobj);
```
查找给定 kobject 的 kobj_type 指针。

### 14.1.2. Kobject 层次结构、Kset 和子系统
