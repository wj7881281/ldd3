## 14.7. Hotplug
有两种不同的方式来查看热插拔。内核将热插拔视为硬件、内核和内核驱动程序之间的交互。用户将热插拔视为内核和用户空间之间通过名为/sbin/hotplug 的程序进行的交互。当内核想要通知用户空间内核中刚刚发生某种类型的热插拔事件时，内核会调用此程序。

### 14.7.1 动态设备
“热插拔”一词最常用的含义是在讨论这样一个事实时出现的：大多数计算机系统现在都可以处理在系统通电时出现或消失的设备。这与几年前的计算机系统有很大不同，当时的程序员知道他们只需要在启动时扫描所有设备，并且他们永远不必担心他们的设备会消失，直到电源关闭为止。现在，随着 USB、CardBus、PCMCIA、IEEE1394 和 PCI Hotplug 控制器的出现，无论在系统中添加或删除什么硬件，Linux 内核都需要能够可靠地运行。这给设备驱动程序作者带来了额外的负担，因为他们现在必须始终处理在没有任何通知的情况下突然从他们下面拔出的设备。

每种不同的总线类型以不同的方式处理设备丢失。例如，当 PCI、CardBus 或 PCMCIA 设备从系统中删除时，通常需要一段时间驱动程序才会通过其删除函数通知此操作。在此之前，所有来自 PCI 总线的读取都会返回所有位设置。这意味着驱动程序需要始终检查从 PCI 总线读取的数据值，并能够正确处理 0xff 值。

drivers/usb/host/ehci-hcd.c 驱动程序中可以看到这样的一个示例，它是 USB 2.0（高速）控制器卡的 PCI 驱动程序。它的主握手循环中有以下代码来检测控制器卡是否已从系统中移除：
```c
result = readl(ptr);
if (result =  = ~(u32)0)    /* card removed */
    return -ENODEV;
```
对于USB驱动程序时，当USB驱动程序的设备从系统中删除时，提交给设备的任何已待处理的URB都会随着ERROR -ENODEV而失败。驱动程序需要识别此错误并正确清除任何挂起的 I/O（如果发生）。

可热插拔设备不仅限于鼠标、键盘和网卡等传统设备。现在有许多系统支持移除和添加整个 CPU 和内存条。幸运的是，Linux 内核正确地处理了此类核心“系统”设备的添加和删除，因此各个设备驱动程序不需要关注这些事情。

### 14.7.2  /sbin/hotplug 实用程序
正如本章前面提到的，每当在系统中添加或删除设备时，都会生成“热插拔事件”。这意味着内核调用用户空间程序/sbin/hotplug。该程序通常是一个非常小的 bash 脚本，仅将执行传递给放置在 /etc/hotplug.d/ 目录树中的其他程序列表。对于大多数 Linux 发行版，此脚本如下所示：

```bash
DIR="/etc/hotplug.d"
for I in "${DIR}/$1/"*.hotplug "${DIR}/"default/*.hotplug ; do
    if [ -f $I ]; then
        test -x $I && $I $1 ;
    fi
done
exit 1
```
换句话说，该脚本搜索所有可能对此事件感兴趣的带有 .hotplug 后缀的程序并调用它们，向它们传递内核设置的许多不同的环境变量。有关 /sbin/hotplug 脚本如何工作的更多详细信息可以在程序的注释和 hotplug(8) 联机帮助页中找到。

如前所述，每当创建或销毁 kobject 时都会调用 /sbin/hotplug。使用提供事件名称的单个命令行参数来调用热插拔程序。涉及的核心内核和特定子系统还设置了一系列环境变量（如下所述），其中包含有关刚刚发生的情况的信息。热插拔程序使用这些变量来确定内核中刚刚发生的情况，以及是否应该执行任何特定操作。

传递给 /sbin/hotplug 的命令行参数是与此热插拔事件关联的名称，由分配给 kobject 的 kset 确定。这个名称可以通过调用 name 函数来设置，该函数是本章前面描述的 kset 的 hotplug_ops 结构的一部分；如果该函数不存在或从未被调用，则该名称是 kset 本身的名称。

始终为 /sbin/hotplug 程序设置的默认环境变量是：

__ACTION__ :字符串添加或删除，具体取决于相关对象是刚刚创建还是销毁。

__DEVPATH__ :sysfs 文件系统中的目录路径，指向正在创建或销毁的 kobject。请注意，sysfs 文件系统的挂载点不会添加到此路径中，因此由用户空间程序来确定。

__SEQNUM__ : 此热插拔事件的序列号。序列号是一个 64 位数字，每次生成热插拔事件时都会递增。这允许用户空间按照内核生成热插拔事件的顺序对热插拔事件进行排序，因为用户空间程序可能会乱序运行。

__SUBSYSTEM__ :如上所述，相同的字符串作为命令行参数传递。

当在系统中添加或删除与总线关联的设备时，许多不同的总线子系统都会将自己的环境变量添加到 /sbin/hotplug 调用中。它们在分配给总线的 struct kset_hotplug_ops 中指定的热插拔回调中执行此操作（如第 14.3.1 节所述）。这允许用户空间能够自动加载控制总线已找到的设备可能需要的任何必要模块。以下是不同总线类型以及它们添加到 /sbin/hotplug 调用的环境变量的列表。

#### 14.7.2.1 IEEE1394 (FireWire)
IEEE1394 总线（也称为 Firewire）上的任何设备都具有 /sbin/hotplug 参数名称，并将 SUBSYSTEM 环境变量设置为值 ieee1394。 ieee1394 子系统还始终添加以下四个环境变量：

__VENDOR_ID__ :IEEE1394 设备的 24 位供应商 ID

__MODEL_ID__ : IEEE1394 设备的 24 位型号 ID

__GUID__ : 设备的 64 位 GUID

__SPECIFIER_ID__ :指定该设备的协议规范所有者的 24 位值

__VERSION__ :指定该设备的协议规范版本的值

#### 14.7.2.2 网络
当设备在内核中注册或取消注册时，所有网络设备都会创建热插拔事件。/sbin/hotplug 调用将参数名称和 SUBSYSTEM 环境变量设置为值 net，并且仅添加以下环境变量：

__INTERFACE__ : 已从内核注册或取消注册的接口的名称。 lo 和 eth0 就是这样的例子。

#### 14.7.2.3 PCI
PCI 总线上的任何设备都具有参数名称和设置为值 pci 的 SUBSYSTEM 环境变量。 PCI 子系统还始终添加以下四个环境变量：

__PCI_CLASS__ :设备的 PCI 类号（十六进制）。

__PCI_ID__ :设备的 PCI 供应商和设备 ID（以十六进制表示）以供应商:设备格式组合。

__PCI_SUBSYS_ID__ :PCI 子系统供应商和子系统设备 ID，以 subsys_vendor:subsys_device 格式组合。

__PCI_SLOT_NAME__ :由内核赋予设备的 PCI 插槽“名称”。它的格式为域：总线：插槽：功能。例如 0000:00:0d.0。

#### 14.7.2.4 Input
对于所有输入设备（鼠标、键盘、操纵杆等），在内核中添加和删除设备时都会生成热插拔事件。/sbin/hotplug 参数和 SUBSYSTEM 环境变量设置为输入值。输入子系统还始终添加以下环境变量：

__PRODUCT__ :列出十六进制值且不带前导零的多值字符串。它的格式为总线类型：供应商：产品：版本。
如果设备支持，则可能存在以下环境变量：

__NAME__ :设备给定的输入设备的名称。

__PHYS__ : 输入子系统提供给该设备的设备物理地址。它应该是稳定的，具体取决于设备插入的总线位置。

__EV__

__KEY__

__REL__

__ABS__

__MSC__

__LED__

__SND__

__FF__

这些都来自输入设备描述符，并且如果特定输入设备支持，则设置为适当的值。

#### 14.7.2.5 USB
USB 总线上的任何设备都将参数名称和 SUBSYSTEM 环境变量设置为值 usb。 USB 子系统还始终添加以下环境变量：

__PRODUCT__ : 格式为 idVendor/idProduct/bcdDevice 的字符串，用于指定 USB 设备特定的字段

__TYPE__ :bDeviceClass/bDeviceSubClass/bDeviceProtocol 格式的字符串，指定 USB 设备特定字段

如果 bDeviceClass 字段设置为 0，则还会设置以下环境变量：

__INTERFACE__ :bInterfaceClass/bInterfaceSubClass/bInterfaceProtocol 格式的字符串，指定这些 USB 设备特定字段。

如果选择了内核构建选项 CONFIG_USB_DEVICEFS（它选择要在内核中构建的 usbfs 文件系统），则还会设置以下环境变量：

__DEVICE__ :一个字符串，显示设备在 usbfs 文件系统中的位置。该字符串的格式为 /proc/bus/usb/USB_BUS_NUMBER/USB_DEVICE_NUMBER，其中 USB_BUS_NUMBER 是设备所在 USB 总线的三位数，USB_DEVICE_NUMBER 是由设备分配的三位数。内核到该 USB 设备。

#### 14.7.2.6 SCSI
当 SCSI 设备在内核中创建或删除时，所有 SCSI 设备都会创建热插拔事件。对于从系统中添加或删除的每个 SCSI 设备，/sbin/hotplug 调用将参数名称和 SUBSYSTEM 环境变量设置为值 scsi。SCSI系统没有添加额外的环境变量，但这里提到它是因为有一个SCSI特定的用户空间脚本可以确定应该为指定的环境加载哪些SCSI驱动程序（磁盘、磁带、通用等） SCSI 设备。

#### 14.7.2.7 Laptop docking stations
如果从正在运行的 Linux 系统中添加或删除支持即插即用的笔记本电脑扩展坞（通过将笔记本电脑插入扩展坞或将其删除），则会创建热插拔事件。 /sbin/hotplug 调用将参数名称和 SUBSYSTEM 环境变量设置为值停靠点。没有设置其他环境变量。

#### 14.7.2.8 S/390 and zSeries
在S/390架构上，通道总线架构支持多种硬件，所有这些硬件在Linux虚拟系统中添加或删除时都会生成/sbin/hotplug事件。这些设备都有 /sbin/hotplug 参数名称，并且 SUBSYSTEM 环境变量设置为值 dasd。没有设置其他环境变量。

### 14.7.3. Using /sbin/hotplug
现在，Linux 内核正在为内核中添加和删除的每个设备调用 /sbin/hotplug，因此在用户空间中创建了许多非常有用的工具来利用这一点。最流行的两个工具是 Linux Hotplug 脚本和 udev。

#### 14.7.3.1 Linux hotplug scripts
Linux 热插拔脚本是作为 /sbin/hotplug 调用的第一个用户开始的。这些脚本查看内核设置的不同环境变量来描述刚刚发现的设备，然后尝试查找与该设备匹配的内核模块。

如前所述，当驱动程序使用 MODULE_DEVICE_TABLE 宏时，程序 depmod 会获取该信息并创建位于 /lib/module/KERNEL_VERSION/modules.\*map 中的文件。  区分\*  ，具体取决于驱动程序支持的总线类型。目前，模块映射文件是为支持 PCI、USB、IEEE1394、INPUT、ISAPNP 和 CCW 子系统的设备的驱动程序生成的。

热插拔脚本使用这些模块映射文本文件来确定尝试加载哪个模块来支持内核最近发现的设备。它们加载所有模块并且不会在第一个匹配处停止，以便让内核找出哪个模块工作得最好。当设备被移除时，这些脚本不会卸载任何模块。如果他们尝试这样做，他们可能会意外关闭也由与被删除设备相同的驱动程序控制的设备。

请注意，现在 modprobe 程序可以直接从模块读取 MODULE_DEVICE_TABLE 信息，而无需模块映射文件，因此热插拔脚本可能会简化为 modprobe 程序的小包装。

#### 14.7.3.2 udev
在内核中创建统一驱动程序模型的主要原因之一是允许用户空间以动态方式管理 /dev 树。以前这是通过 devfs 的实现在用户空间中完成的，但由于缺乏活跃的维护者和一些无法修复的核心错误，该代码库已经慢慢腐烂。许多内核开发人员意识到，如果将所有设备信息导出到用户空间，则可以执行 /dev 树的所有必要管理。

devfs 在其设计中存在一些非常根本的缺陷。它要求修改每个设备驱动程序以支持它，并且要求设备驱动程序指定其在 /dev 树中放置的名称和位置。它还不能正确处理动态主设备号和次设备号，并且不允许用户空间以简单的方式覆盖设备的命名，从而强制设备命名策略驻留在内核中而不是用户空间中。Linux 内核开发人员真的很讨厌在内核中制定策略，并且由于 devfs 命名策略不遵循 Linux Standard Base 规范，这确实让他们感到困扰。

随着Linux内核开始安装在大型服务器上，许多用户遇到了如何管理大量设备的问题。由超过 10,000 个独特设备组成的磁盘驱动器阵列提出了一项非常艰巨的任务，即确保特定磁盘始终以相同的确切名称命名，无论该磁盘位于磁盘阵列中的何处或何时被内核发现。同样的问题也困扰着桌面用户，他们尝试将两台 USB 打印机插入系统，然后意识到，如果系统发生故障，他们无法确保名为 /dev/lpt0 的打印机不会更改并分配给另一台打印机。重新启动。

于是，udev就被创建了。它依赖于通过 sysfs 将所有设备信息导出到用户空间，并依赖于 /sbin/hotplug 通知设备已添加或删除。策略决策，例如给设备起什么名字，可以在内核之外的用户空间中指定。这确保了命名策略从内核中删除，并允许每个设备的名称具有很大的灵活性。

有关如何使用 udev 以及如何配置它的更多信息，请参阅您的发行版中 udev 包附带的文档。

为了让 udev 正常工作，设备驱动程序需要做的就是确保分配给驱动程序控制的设备的任何主设备号和次设备号都通过 sysfs 导出到用户空间。对于任何使用子系统为其分配主编号和次编号的驱动程序，这已经由子系统完成，并且驱动程序不需要执行任何工作。执行此操作的子系统示例包括 tty、misc、usb、input、scsi、block、i2c、网络和帧缓冲区子系统。如果您的驱动程序通过调用 cdev_init 函数或旧的 register_chrdev 函数自行处理获取主设备号和次设备号，则需要修改驱动程序才能使 udev 正常工作。

udev 在 sysfs 的 /class/ 树中查找名为 dev 的文件，以便确定内核通过 /sbin/hotplug 接口调用特定设备时分配给该设备的主设备号和次设备号。设备驱动程序只需要为其控制的每个设备创建该文件。 class_simple 接口通常是执行此操作的最简单方法。

正如第 14.5.1 节中提到的，使用 class_simple 接口的第一步是通过调用 class_simple_create 函数创建一个 struct class_simple ：

```c
static struct class_simple *foo_class;
...
foo_class = class_simple_create(THIS_MODULE, "foo");
if (IS_ERR(foo_class)) {
    printk(KERN_ERR "Error creating foo class.\n");
    goto error;
}
```

此代码在 sysfs 的 /sys/class/foo 中创建一个目录。

每当你的驱动程序发现一个新设备，并且你按照第 3 章中的描述为它分配一个次设备号时，驱动程序应该调用 class_simple_device_add 函数：
```c
class_simple_device_add(foo_class, MKDEV(FOO_MAJOR, minor), NULL, "foo%d", minor);
```

此代码会导致在 /sys/class/foo 下创建一个名为 fooN 的子目录，其中 N 是该设备的次设备号。在此目录中创建了一个文件 dev，这正是 udev 为您的设备创建设备节点所需的文件。

当您的驱动程序与设备解除绑定，并且您放弃它所附加的次设备号时，需要调用 class_simple_device_remove 来删除该设备的 sysfs 条目：

```c
class_simple_device_remove(MKDEV(FOO_MAJOR, minor));
```
稍后，当您的整个驱动程序被关闭时，需要调用 class_simple_destroy 来删除您最初通过调用 class_simple_create 创建的类：
```c
class_simple_destroy(foo_class);
```
通过调用 class_simple_device_add 创建的 dev 文件由主设备号和次设备号组成，并用 : 字符分隔。如果您的驱动程序不想使用 class_simple 接口，因为您想在子系统的类目录中提供其他文件，请使用 print_dev_t 函数正确格式化特定设备的主设备号和次设备号。


