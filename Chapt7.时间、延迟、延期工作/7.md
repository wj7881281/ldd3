## 7.1测量时间的流逝
## 7.2知道当前的时间
## 7.3延迟执行
### 7.3.1长延迟
#### 7.3.1.2切换线程
我们都知道，上一节的Busy wait对于整个系统是个沉重的负担，我们有更好的技术，我们映入脑子第一反应就是干脆对于要阻塞的进程直接释放对于CPU的hold（控制），能完成这个动作的函数就是schedule他定义在linux/sched.h。
```c
while (time_before(jiffies, j1)) {
    schedule(  );
}
```
如果模块加载成功会有/proc/jitsched，然而着还不是最佳的，当前进程释放了CPU但是还是处于运行状态，如果只有他一个进程那还是会继续运行，释放完CPU由于没有其他进程很快此进程还是会重新运行，CPU平均负载决定了必须至少有一个进程，空闲进程（swapper）不会运行，空闲时间运行空闲进程有很多好处，降低温度，延长笔记本寿命等，在delay不过内核依然会关注此进程统计时间随时切换回来等。

有个好玩的现象，每次延迟ticks都不会太准确都会多几个ticks，随着系统负载越来越重多耗几个ticks的现象也会严重，覆水难收你释放了cpu控制通过schedule，要想快速再次拿取cpu掌控就困难了，所以通过schedule并不能安全满足你的需求，并会为整个系统增加安全隐患，当你运行load50案例时你会发现时间会延长几秒，因为其他进程正在使用cpu当时间到了。

#### 7.3.1.3 超时
有个次优的方式就是偷偷观察jiffy寄存器，当然最好的实现delay方式就是告诉内核让他来做延迟，下面有两种方式实现的delay当然他们都是依赖jiffy寄存器

你如果进程使用等待队列等待其他事件，但你不想一直等待，使用wait_event_timeout 或者wait_event_interruptible_timeout
```
#include <linux/wait.h>
long wait_event_timeout(wait_queue_head_t q, condition, long timeout);
long wait_event_interruptible_timeout(wait_queue_head_t q,
                      condition, long timeout);
```
执行这些函数会导致睡眠进程被推入等待队列了，时间到了/超时会被自动唤醒，这样他们就是有限睡眠不会永远沉睡，请注意延迟的是jiffies值不是绝对时间，超时时间变量是有符号数，也就意味着他可以是复数，虽然这样做会打印告警，超时时间到了上面函数会返回0。如果被其他进程唤醒了返回剩余jiffers值，记住返回值永远不会是负数不管系统负载有多大。

/proc/jitqueue 这个案例使用的是下面的接口,没有等待的事件写入0
```
wait_queue_head_t wait;
init_waitqueue_head (&wait);
wait_event_interruptible_timeout(wait, 0, delay);
```
通过观察案例结果，上面的使用似乎是最佳的，即使是系统大负载情况下。
wait_event_timeout和wait_event_interruptible_timeout在设计之初就和硬件深度绑定，可以通过下面两种方式恢复：用wake_up函数唤醒等待队列或者时间到达，由于没人唤醒等待队列最终还是时间到了进程被唤醒。上面还是太麻烦我们还提供更简单的方式，我们不需要事件唤醒所以内核提供了schedule_timeout函数这样就不需要定义等待队列
```
#include <linux/sched.h>
signed long schedule_timeout(signed long timeout);
```
timeout就是我们需要delay延迟的jiffes数，正常返回值是0除非是一些信号中断了，使用前需要设置进程的状态再调用schedule_timeout函数，如下
```
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout (delay);
```
/proc/jitschedto 案例，执行上面语句，进程会睡眠直到时间到达，其实wait_event_interruptible_timeout底层也是调用schedule_timeout来实现超时唤醒功能，再次强调下，超时时间到了和实际执行进程之间还是有一定间隔