## 7.1测量时间的流逝
## 7.2知道当前的时间
## 7.3延迟执行
### 7.3.1长延迟
#### 7.3.1.2切换线程
我们都知道，上一节的Busy wait对于整个系统是个沉重的负担，我们有更好的技术，我们映入脑子第一反应就是干脆对于要阻塞的进程直接释放对于CPU的hold（控制），能完成这个动作的函数就是schedule他定义在linux/sched.h。
```c
while (time_before(jiffies, j1)) {
    schedule(  );
}
```
如果模块加载成功会有/proc/jitsched，然而着还不是最佳的，当前进程释放了CPU但是还是处于运行状态，如果只有他一个进程那还是会继续运行，释放完CPU由于没有其他进程很快此进程还是会重新运行，CPU平均负载决定了必须至少有一个进程，空闲进程（swapper）不会运行，空闲时间运行空闲进程有很多好处，降低温度，延长笔记本寿命等，在delay不过内核依然会关注此进程统计时间随时切换回来等。

有个好玩的现象，每次延迟ticks都不会太准确都会多几个ticks，随着系统负载越来越重多耗几个ticks的现象也会严重，覆水难收你释放了cpu控制通过schedule，要想快速再次拿取cpu掌控就困难了，所以通过schedule并不能安全满足你的需求，并会为整个系统增加安全隐患，当你运行load50案例时你会发现时间会延长几秒，因为其他进程正在使用cpu当时间到了。

#### 7.3.1.3 超时
有个次优的方式就是偷偷观察jiffy寄存器，当然最好的实现delay方式就是告诉内核让他来做延迟，下面有两种方式实现的delay当然他们都是依赖jiffy寄存器

你如果进程使用等待队列等待其他事件，但你不想一直等待，使用wait_event_timeout 或者wait_event_interruptible_timeout
```
#include <linux/wait.h>
long wait_event_timeout(wait_queue_head_t q, condition, long timeout);
long wait_event_interruptible_timeout(wait_queue_head_t q,
                      condition, long timeout);
```
执行这些函数会导致睡眠进程被推入等待队列了，时间到了/超时会被自动唤醒，这样他们就是有限睡眠不会永远沉睡，请注意延迟的是jiffies值不是绝对时间，超时时间变量是有符号数，也就意味着他可以是复数，虽然这样做会打印告警，超时时间到了上面函数会返回0。如果被其他进程唤醒了返回剩余jiffers值，记住返回值永远不会是负数不管系统负载有多大。

/proc/jitqueue 这个案例使用的是下面的接口,没有等待的事件写入0
```
wait_queue_head_t wait;
init_waitqueue_head (&wait);
wait_event_interruptible_timeout(wait, 0, delay);
```
通过观察案例结果，上面的使用似乎是最佳的，即使是系统大负载情况下。
wait_event_timeout和wait_event_interruptible_timeout在设计之初就和硬件深度绑定，可以通过下面两种方式恢复：用wake_up函数唤醒等待队列或者时间到达，由于没人唤醒等待队列最终还是时间到了进程被唤醒。上面还是太麻烦我们还提供更简单的方式，我们不需要事件唤醒所以内核提供了schedule_timeout函数这样就不需要定义等待队列
```
#include <linux/sched.h>
signed long schedule_timeout(signed long timeout);
```
timeout就是我们需要delay延迟的jiffes数，正常返回值是0除非是一些信号中断了，使用前需要设置进程的状态再调用schedule_timeout函数，如下
```k
set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout (delay);
```
/proc/jitschedto 案例，执行上面语句，进程会睡眠直到时间到达，其实wait_event_interruptible_timeout底层也是调用schedule_timeout来实现超时唤醒功能，再次强调下，超时时间到了和实际执行进程之间还是有一定间隔，注意一点上面的函数set_current_state用来设置进程当前状态直到延迟时间到了他又被切换回TASK_RUNNING进程又能重新运行，如果你想不间断延迟可以使用TASK_UNINTERRUPTIBLE，如果你忘记修改进程状态那么schedule_timeout的行为有点类似schedule，顶多加上一个没有使用时间定时器（可能不会在预期的时间内唤醒进程，导致定时器似乎不起作用）。
如果你想在不同环境或者内核下使用上面四个Jit文件，或者采用其他方式执行，当加载模块时后面带参数这样模块就可以执行延迟。

### 7.3.2短延迟
当设备驱动程序需要处理其硬件中的延迟时，所涉及的延迟通常最多为几十微秒。在这种情况下，依靠时钟滴答绝对不是可行的方法。
内核函数 ndelay、udelay 和 mdelay 非常适合短延迟，分别将执行延迟指定的纳秒、微秒或毫秒数。[2]他们的原型是：
```c
#include <linux/delay.h>
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs);
void mdelay(unsigned long msecs);
```


这些函数的实际实现位于 asm/delay.h 中，是特定于体系结构的，有时构建在外部函数上,每个架构都实现了 udelay，但其他功能可能已定义，也可能未定义；如果不是，linux/delay.h 会提供基于 udelay 的默认版本。在所有情况下，实现的延迟至少是所请求的值，但也可能更高；实际上，目前还没有平台能够达到纳秒精度，尽管有几个平台可以提供亚微秒精度。延迟超过请求的值通常不是问题，因为驱动程序通常需要短延迟来等待硬件，并且要求至少等待给定的时间间隔。

udelay（也可能是 ndelay）的实现使用基于启动时计算的处理器速度的软件循环，使用整数变量loops_per_jiffy 
> loops_per_jiffy 是一个在Linux内核中用于计时和延迟操作的关键变量，它允许内核根据处理器的性能来控制时间延迟。这有助于确保内核操作在各种硬件环境下能够按照期望的方式运行。

但是，如果您想查看实际代码，请注意 x86 实现相当复杂，因为根据运行代码的 CPU 类型，它使用不同的计时源。

为了避免循环计算中的整数溢出，udelay 和 ndelay 对传递给它们的值施加上限。如果您的模块无法加载并显示未解析的符号 _ _bad_udelay，则意味着您使用太大的参数调用 udelay。但请注意，编译时检查只能对常量值执行，并且并非所有平台都实现它。作为一般规则，如果您尝试延迟数千纳秒，则应该使用 udelay 而不是 ndelay；同样，毫秒级的延迟应该使用 mdelay 来完成，而不是使用更细粒度的函数之一。

重要的是要记住，三个延迟函数都是忙等待；在此时间内无法运行其他任务。因此，它们复制了“jitbusy”的行为，尽管规模不同。因此，只有在没有实际替代方案时才应使用这些功能。

还有另一种方法可以实现毫秒（和更长）的延迟，但不涉及忙等待。文件 linux/delay.h 声明了这些函数
```c
void msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);
void ssleep(unsigned int seconds)
```
前两个函数使调用进程休眠给定的毫秒数,对 msleep 的调用是不间断的；您可以确保该进程至少休眠给定的毫秒数。如果您的驱动程序位于等待队列中，并且您希望唤醒来打破睡眠状态，请使用 msleep_interruptible。msleep_interruptible的返回值通常为0；然而，如果进程被提前唤醒，则返回值是最初请求的睡眠周期中剩余的毫秒数。调用 ssleep 会使进程进入不间断睡眠状态并持续给定的秒数。

一般来说，如果您可以容忍比请求的延迟更长的时间，则应该使用schedule_timeout、msleep 或ssleep。

## 7.4内核时间
