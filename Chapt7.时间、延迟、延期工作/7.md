## 7.1测量时间的流逝
## 7.2知道当前的时间
## 7.3延迟执行
### 7.3.1长延迟
#### 7.3.1.2切换线程
我们都知道，上一节的Busy wait对于整个系统是个沉重的负担，我们有更好的技术，我们映入脑子第一反应就是干脆对于要阻塞的进程直接释放对于CPU的hold（控制），能完成这个动作的函数就是schedule他定义在linux/sched.h。
```c
while (time_before(jiffies, j1)) {
    schedule(  );
}
```
如果模块加载成功会有/proc/jitsched，然而着还不是最佳的，当前进程释放了CPU但是还是处于运行状态，如果只有他一个进程那还是会继续运行，释放完CPU由于没有其他进程很快此进程还是会重新运行，CPU平均负载决定了必须至少有一个进程，空闲进程（swapper）不会运行，空闲时间运行空闲进程有很多好处，降低温度，延长笔记本寿命等，在delay不过内核依然会关注此进程统计时间随时切换回来等。

有个好玩的现象，每次延迟ticks都不会太准确都会多几个ticks，随着系统负载越来越重多耗几个ticks的现象也会严重，覆水难收你释放了cpu控制通过schedule，要想快速再次拿取cpu掌控就困难了，所以通过schedule并不能安全满足你的需求，并会为整个系统增加安全隐患，当你运行load50案例时你会发现时间会延长几秒，因为其他进程正在使用cpu当时间到了。

#### 7.3.1.3 超时


