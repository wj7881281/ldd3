## 9.2. Using I/O Ports
I/O 端口是驱动程序与许多设备（至少在部分时间）进行通信的方式。本节介绍了可用于使用 I/O 端口的各种功能；我们还涉及一些可移植性问题。

### 9.2.1. I/O端口分配
正如您所期望的，在没有首先确保您具有对这些端口的独占访问权限之前，您不应该开始攻击 I/O 端口。内核提供了一个注册接口，允许您的驱动程序声明其所需的端口。该接口中的核心函数是request_region：
```c
#include <linux/ioport.h>
struct resource *request_region(unsigned long first, unsigned long n, 
                                const char *name);
```
该函数告诉内核您想要使用 n 个端口，从第一个端口开始。name 参数应该是您的设备的名称。如果分配成功，则返回值为非 NULL。如果从 request_region 返回 NULL，您将无法使用所需的端口。

所有端口分配都显示在 /proc/ioports 中。如果您无法分配所需的一组端口，则可以在此处查看谁先到达那里。

当您完成一组 I/O 端口（可能在模块卸载时）时，应使用以下命令将它们返回到系统：
```c
void release_region(unsigned long start, unsigned long n);
```
还有一个函数允许您的驱动程序检查一组给定的 I/O 端口是否可用：
```c
int check_region(unsigned long first, unsigned long n);
```
此处，如果给定端口不可用，则返回值为负错误代码。该函数已被弃用，因为它的返回值不能保证分配是否成功；检查和稍后分配不是原子操作。我们在这里列出它是因为有几个驱动程序仍在使用它，但您应该始终使用 request_region，它执行所需的锁定以确保分配以安全、原子的方式完成。

### 9.2.2.操作 I/O 端口
当驱动程序请求其活动中需要使用的 I/O 端口范围后，它必须读取和/或写入这些端口。为此，大多数硬件都会区分 8 位、16 位和 32 位端口。通常您不能像平常处理系统内存访问那样混合使用它们。[2]
> 有时，I/O 端口的排列方式与内存类似，例如，您可以将两个 8 位写入绑定到单个 16 位操作中。例如，这适用于 PC 视频板。但一般来说，您不能指望此功能。

因此，C 程序必须调用不同的函数来访问不同大小的端口。正如上一节中所建议的，仅支持内存映射 I/O 的计算机体系结构通过将端口地址重新映射到内存地址来注册假端口 I/O，并且内核向驱动程序隐藏详细信息以简化可移植性。Linux 内核头文件（具体来说，依赖于体系结构的头文件 asm/io.h ）定义了以下内联函数来访问 I/O 端口：
```c
unsigned inb(unsigned port);
void outb(unsigned char byte, unsigned port);
```
读取或写入字节端口（八位宽）。对于某些平台，端口参数定义为 unsigned long，对于其他平台，端口参数定义为 unsigned Short。 inb 的返回类型在不同的架构中也不同。
```c
unsigned inw(unsigned port);
void outw(unsigned short word, unsigned port);
```
这些函数访问 16 位端口（一个字宽）；当针对仅支持字节 I/O 的 S390 平台进行编译时，它们不可用。
```c
unsigned inl(unsigned port);
void outl(unsigned longword, unsigned port);
```
这些函数访问 32 位端口。根据平台，longword 被声明为 unsigned long 或 unsigned int。与字 I/O 一样，“长”I/O 在 S390 上不可用。

> 从现在开始，当我们在没有进一步类型规范的情况下使用 unsigned 时，我们指的是依赖于体系结构的定义，其确切性质并不相关。这些函数几乎总是可移植的，因为编译器在赋值期间自动转换值 - 它们的无符号有助于防止编译时警告。只要程序员分配合理的值以避免溢出，这种类型转换就不会丢失任何信息。我们在本章中始终坚持“不完整打字”的惯例。

请注意，未定义 64 位端口 I/O 操作。即使在 64 位架构上，端口地址空间也使用 32 位（最大）数据路径。

### 9.2.3.从用户空间访问 I/O 端口
刚刚描述的函数主要供设备驱动程序使用，但它们也可以从用户空间使用，至少在 PC 级计算机上是这样。GNU C 库在 sys/io.h 中定义它们。为了在用户空间代码中使用 inb 和朋友，应满足以下条件：

- 必须使用 -O 选项编译程序以强制扩展内联函数。
- 必须使用 ioperm 或 iopl 系统调用来获取在端口上执行 I/O 操作的权限。ioperm 获得单个端口的权限，而 iopl 获得整个 I/O 空间的权限。这两个函数都是 x86 特定的。
- 该程序必须以 root 身份运行才能调用 ioperm 或 iopl。或者，其祖先之一必须获得以 root 身份运行的端口访问权限。

[3] 从技术上讲，它必须具有 CAP_SYS_RAWIO 功能，但这与在大多数当前系统上以 root 身份运行相同。

如果主机平台没有 ioperm 和 iopl 系统调用，用户空间仍然可以使用 /dev/port 设备文件访问 I/O 端口。但请注意，该文件的含义是非常特定于平台的，除了 PC 之外，不太可能对任何其他设备有用。

示例源misc-progs/inp.c 和misc-progs/outp.c 是在用户空间中从命令行读写端口的最小工具。它们期望以多个名称安装（例如，inb、inw 和 inl，并根据用户调用的名称来操作字节、字或长端口）。他们在x86下使用ioperm或iopl，在其他平台上使用/dev/port。

如果您想危险地生活并在不获取显式特权的情况下使用您的硬件，则可以将程序设置为 setuid root。但是，请不要在生产系统上安装它们 setuid；它们是设计上的安全漏洞。

### 9.2.4.字符串操作
除了单次输入和输出操作之外，一些处理器还实现特殊指令，以在单个 I/O 端口或相同大小的端口之间传输字节、字或长整型序列。这些就是所谓的字符串指令，它们执行任务的速度比 C 语言循环更快。以下宏通过使用单个机器指令或通过执行紧密循环（如果目标处理器没有执行字符串 I/O 的指令）来实现字符串 I/O 的概念。针对 S390 平台编译时根本没有定义宏。这不应该是可移植性问题，因为该平台通常不与其他平台共享设备驱动程序，因为它的外围总线不同。

字符串函数的原型是：
```c
void insb(unsigned port, void *addr, unsigned long count);
void outsb(unsigned port, void *addr, unsigned long count);
```
从内存地址 addr 开始读取或写入 count 个字节。从单端口读取数据或将数据写入单端口。

```c
void insw(unsigned port, void *addr, unsigned long count);
void outsw(unsigned port, void *addr, unsigned long count);
```
将 16 位值读取或写入单个 16 位端口。

```c
void insl(unsigned port, void *addr, unsigned long count);
void outsl(unsigned port, void *addr, unsigned long count);
```
将 32 位值读取或写入单个 32 位端口。

使用字符串函数时需要记住一件事：它们将直接字节流移入或移出端口。当端口和主机系统具有不同的字节排序规则时，结果可能会令人惊讶。如果需要，使用 inw 读取端口会交换字节，以使读取的值与主机顺序匹配。相反，字符串函数不执行此交换。

### 9.2.5。暂停 I/O
某些平台（尤其是 i386）在处理器尝试过快地与总线传输数据或从总线传输数据时可能会出现问题。当处理器相对于外设总线（此处考虑 ISA）超频时，就会出现问题，并且当设备板速度太慢时，问题也会出现。解决方案是在每个 I/O 指令后面插入一个小的延迟（如果后面跟着另一个这样的指令）。在 x86 上，暂停是通过对端口 0x80 执行 out b 指令（通常但并不总是未使用）或通过忙等待来实现的。有关详细信息，请参阅平台的 asm 子目录下的 io.h 文件。

如果您的设备丢失了一些数据，或者您担心它可能会丢失一些数据，您可以使用暂停功能来代替正常功能。暂停函数与前面列出的完全相同，但它们的名称以 _p 结尾；它们被称为 inb_p、outb_p 等等。这些函数是为大多数支持的体系结构定义的，尽管它们通常扩展为与非暂停 I/O 相同的代码，因为如果体系结构使用相当现代的外设总线运行，则不需要额外的暂停。

### 9.2.6。平台依赖性
I/O 指令本质上是高度依赖处理器的。因为它们涉及处理器如何处理数据移入和移出的细节，所以很难隐藏系统之间的差异。因此，与端口 I/O 相关的大部分源代码都是平台相关的。

通过回顾函数列表，您可以看到不兼容性之一，即数据类型，其中根据平台之间的架构差异，参数的类型有所不同。例如，端口在 x86（处理器支持 64 KB I/O 空间）上是 unsigned Short，但在其他平台上是 unsigned long，这些平台的端口只是与内存相同的地址空间中的特殊位置。

其他平台依赖性源于处理器的基本结构差异，因此是不可避免的。我们不会详细讨论这些差异，因为我们假设您不会在不了解底层硬件的情况下为特定系统编写设备驱动程序。相反，这里概述了内核支持的架构的功能：

__IA-32 (x86)__
__x86_64__
该架构支持本章描述的所有功能。端口号的类型为无符号短整型。

__IA-64 (Itanium)__
所有功能均支持；端口是无符号长整型（并且是内存映射的）。字符串函数是用 C 实现的。

__Alpha__
支持所有功能，并且端口是内存映射的。根据所使用的芯片组，端口 I/O 的实现在不同的 Alpha 平台中是不同的。字符串函数用 C 实现并在 arch/alpha/lib/io.c 中定义。端口是无符号长的。

__ARM__
端口内存映射，支持所有功能；字符串函数在 C 中实现。端口的类型为 unsigned int。

__Cris__
即使在仿真模式下，该架构也不支持 I/O 端口抽象；各种端口操作被定义为不执行任何操作。

好奇的读者可以从 io.h 文件中提取更多信息，除了我们在本章中描述的函数之外，这些文件有时还定义了一些特定于体系结构的函数。但请注意，其中一些文件相当难以阅读。有趣的是，x86 系列之外的处理器没有一个具有不同的端口地址空间，尽管一些受支持的系列附带 ISA 和/或 PCI 插槽（并且两种总线都实现独立的 I/O 和内存地址空间）。

此外，一些处理器（尤其是早期的 Alpha）缺乏一次移动一两个字节的指令。因此，它们的外设芯片组通过将 8 位和 16 位 I/O 映射到内存地址空间中的特殊地址范围来模拟它们。因此，作用于同一端口的 inb 和 inw 指令是通过对不同地址进行操作的两个 32 位内存读取来实现的。幸运的是，所有这些都通过本节中描述的宏的内部结构对设备驱动程序编写者隐藏，但我们认为这是一个值得注意的有趣功能。如果您想进一步探究，请在 include/asm-alpha/core_lca.h 中查找示例。

> 单字节 I/O 并不像人们想象的那么重要，因为它是一种罕见的操作。要将单个字节读/写到任何地址空间，您需要实现一个数据路径，将寄存器集数据总线的低位连接到外部数据总线中的任何字节位置。这些数据路径需要额外的逻辑门，从而妨碍每次数据传输。放弃字节宽度的加载和存储可以有利于整体系统性能。

每个平台的 I/O 操作如何执行在每个平台的程序员手册中都有详细描述；这些手册通常可以在网上以 PDF 形式下载。
