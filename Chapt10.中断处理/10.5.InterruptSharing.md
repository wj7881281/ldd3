## 10.5. 中断共享
IRQ冲突是一个在PC体系结构中较为普遍的问题，而了解和解决IRQ冲突是维护和管理个人计算机系统稳定性的一部分。过去，PC 上的 IRQ 线路无法为多个设备提供服务，而且数量也从未足够。因此，沮丧的用户经常花很多时间打开他们的电脑机箱，试图找到一种方法让他们的所有外围设备都能很好地协同工作。

当然，现代硬件的设计允许共享中断;PCI 总线需要它。因此，Linux 内核支持所有总线上的中断共享，即使是那些传统上不支持共享的总线（如 ISA 总线）。如果目标硬件可以支持共享中断，则应编写 2.6 内核的设备驱动程序以使用共享中断。幸运的是，大多数时候，使用共享中断很容易。

### 10.5.1. 安装共享处理程序
共享中断通过request_irq安装，就像非共享中断一样，但有两个区别：
- 请求中断时，必须在 flags 参数中指定 SA_SHIRQ 位。
- dev_id参数必须是唯一的。任何指向模块地址空间的指针都可以，但绝对不能dev_id设置为 NULL。

内核保留了与中断关联的共享处理程序列表，dev_id可以被视为区分它们的签名。如果两个驱动程序在同一中断上将 NULL 注册为签名，则在卸载时可能会混淆，从而导致内核在中断到达时发出 oops 声。出于这个原因，如果在注册共享中断时传递了 NULL dev_id，现代内核会大声抱怨。请求共享中断时，如果满足以下条件之一，则request_irq成功：
- 中断线是空闲的。
- 与某个IRQ line相关的所有中断处理程序都已经在系统中注册，并且这些处理程序都明确指定了该IRQ是可共享的

每当两个或多个驱动程序共享一条中断行，并且硬件中断该行上的处理器时，内核就会调用为该中断注册的每个处理程序，并传递每个处理程序自己的dev_id。因此，共享处理程序必须能够识别自己的中断，并且应在自己的设备未中断时快速退出。每当调用处理程序并发现设备未中断时，请务必返回IRQ_NONE。

如果你需要在请求 IRQ 线路之前探测你的设备，内核无法帮助你。共享处理程序没有可用的探测功能。如果正在使用的线路是空闲的，则标准探测机制有效，但如果该线路已由另一个具有共享功能的驱动程序持有，则探测将失败，即使驱动程序可以完美运行。幸运的是，大多数设计用于中断共享的硬件也能够告诉处理器它正在使用哪个中断，从而消除了显式探测的需要。

释放处理程序是以正常方式执行的，使用 free_irq。此处，dev_id 参数用于从中断的共享处理程序列表中选择要释放的正确处理程序。这就是为什么dev_id指针必须是唯一的。

使用共享处理程序的驱动程序需要注意另一件事：它不能玩enable_irq或disable_irq。如果是这样，共享线路的其他设备可能会失控;即使短时间内禁用另一台设备的中断，也可能会造成延迟，这对该设备及其用户来说是有问题的。通常，程序员必须记住，他的驱动程序并不拥有 IRQ，并且它的行为应该比拥有中断线时所需的更“社交”。

### 10.5.2. 运行处理程序
如前所述，当内核收到中断时，将调用所有已注册的处理程序。共享处理程序必须能够区分它需要处理的中断和其他设备生成的中断。

使用选项 shared=1 加载short将安装以下处理程序，而不是默认处理程序：
```c
irqreturn_t short_sh_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    int value, written;
    struct timeval tv;

    /* If it wasn't short, return immediately */
    value = inb(short_base);
    if (!(value & 0x80))
        return IRQ_NONE;
    
    /* clear the interrupting bit */
    outb(value & 0x7F, short_base);

    /* the rest is unchanged */

    do_gettimeofday(&tv);
    written = sprintf((char *)short_head,"%08u.%06u\n",
            (int)(tv.tv_sec % 100000000), (int)(tv.tv_usec));
    short_incr_bp(&short_head, written);
    wake_up_interruptible(&short_queue); /* awake any reading process */
    return IRQ_HANDLED;
}
```
这里需要解释。由于并行端口没有要检查的“中断挂起”位，因此处理程序使用 ACK 位来实现此目的。如果该位为高电平，则报告的中断为简称中断，处理程序将清除该位。

该处理程序通过将并行接口数据端口的高位归零来复位 - short假设引脚 9 和 10 连接在一起。如果与 short 共享 IRQ 的其他设备之一产生中断，则 short 会看到自己的线路仍处于非活动状态，并且不执行任何操作。

当然，功能齐全的驱动程序可能会将工作分为上半部分和下半部分，但这很容易添加，并且不会对实现共享的代码产生任何影响。真正的驱动程序还可能使用 dev_id 参数来确定可能许多设备中的哪些设备可能正在中断。

请注意，如果使用打印机（而不是跳线）来测试短路中断管理，则此共享处理程序将无法按宣传的方式工作，因为打印机协议不允许共享，并且驱动程序无法知道中断是否来自打印机。

### 10.5.3. /proc 接口和共享中断
在系统中安装共享处理程序不会影响 /proc/stat，它甚至不知道处理程序。但是，/proc/interrupts 略有变化。

为同一中断号安装的所有处理程序都显示在同一行 /proc/interrupts 上。以下输出（来自x86_64系统）显示了共享中断处理程序的显示方式：
```
           CPU0       
  0:  892335412         XT-PIC  timer
  1:     453971         XT-PIC  i8042
  2:          0         XT-PIC  cascade
  5:          0         XT-PIC  libata, ehci_hcd
  8:          0         XT-PIC  rtc
  9:          0         XT-PIC  acpi
 10:   11365067         XT-PIC  ide2, uhci_hcd, uhci_hcd, SysKonnect SK-98xx, EMU10K1
 11:    4391962         XT-PIC  uhci_hcd, uhci_hcd
 12:        224         XT-PIC  i8042
 14:    2787721         XT-PIC  ide0
 15:     203048         XT-PIC  ide1
NMI:      41234 
LOC:  892193503 
ERR:        102
MIS:          0

```
该系统有几条共享中断线。IRQ 5 用于串行 ATA 和 IEEE 1394 控制器;IRQ 10 具有多个设备，包括一个 IDE 控制器、两个 USB 控制器、一个以太网接口和一个声卡;IRQ 11 也由两个 USB 控制器使用。