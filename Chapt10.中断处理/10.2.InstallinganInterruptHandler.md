## 10.2.安装中断处理程序
如果您想实际“查看”正在生成的中断，仅写入硬件设备是不够的；必须在系统中配置软件处理程序。如果Linux内核没有被告诉预期你的中断，它就会简单地确认并忽略它。

中断线是一种宝贵且通常有限的资源，特别是当只有 15 或 16 条中断线时。内核保留了中断线的注册表，类似于 I/O 端口的注册表。模块应在使用中断通道（或 IRQ，用于中断请求）之前请求它，并在完成后释放它。在许多情况下，模块也应该能够与其他驱动程序共享中断线，正如我们将看到的。linux/interrupt.h 中声明的以下函数实现了中断注册接口：
```c
int request_irq(unsigned int irq,
                irqreturn_t (*handler)(int, void *, struct pt_regs *),
                unsigned long flags, 
                const char *dev_name,
                void *dev_id);

void free_irq(unsigned int irq, void *dev_id);
```
像往常一样，从 request_irq 返回到请求函数的值要么是 0（表示成功），要么是负错误代码。该函数返回 -EBUSY 来表示另一个驱动程序已在使用请求的中断线的情况并不罕见。函数的参数如下：

__unsigned int irq__
正在请求的中断号。

__irqreturn_t (*handler)(int, void *, struct pt_regs *)__
指向正在安装的处理函数的指针。我们将在本章后面讨论该函数的参数及其返回值。

__unsigned long flags__
正如您所期望的，与中断管理相关的选项位掩码（稍后描述）。

__const char *dev_name__
传递给 request_irq 的字符串在 /proc/interrupts 中用于显示中断的所有者（请参阅下一节）。

__void *dev_id__
用于共享中断线的指针。它是释放中断线时使用的唯一标识符，驱动程序也可以使用它来指向其自己的私有数据区域（以识别哪个设备正在中断）。如果中断不是共享的，则 dev_id 可以设置为 NULL，但无论如何使用此项来指向设备结构是一个好主意。我们将在 10.3 节中看到 dev_id 的实际用途。

可以在标志中设置的位如下：

__SA_INTERRUPT__
设置后，这表示“快速”中断处理程序。快速处理程序在当前处理器上禁用中断的情况下执行（该主题在第 10.2.3 节中介绍）。

__SA_SHIRQ__
该位表示中断可以在设备之间共享。第 10.5 节概述了共享的概念。

__SA_SAMPLE_RANDOM__
该位指示生成的中断可以贡献给 /dev/random 和 /dev/urandom 使用的熵池。这些设备在读取时返回真正的随机数，旨在帮助应用程序软件选择安全密钥进行加密。这些随机数是从由各种随机事件贡献的熵池中提取的。如果您的设备在真正随机的时间生成中断，则应该设置此标志。另一方面，如果您的中断是可预测的（例如，图像采集卡的垂直消隐），则该标志不值得设置 - 无论如何它不会对系统熵产生影响。可能受到攻击者影响的设备不应设置此标志；例如，网络驱动程序可能会受到来自外部的可预测数据包时序的影响，并且不应该对熵池做出贡献。有关更多信息，请参阅 drivers/char/random.c 中的注释。

中断处理程序可以在驱动程序初始化时或首次打开设备时安装。虽然从模块的初始化函数中安装中断处理程序听起来是个好主意，但通常不是，特别是如果您的设备不共享中断。由于中断线的数量是有限的，因此您不想浪费它们。您很容易就会发现计算机中的设备数量多于中断数量。如果模块在初始化时请求 IRQ，它将阻止任何其他驱动程序使用该中断，即使持有该中断的设备从未使用过。另一方面，在设备打开时请求中断允许某些资源共享。

例如，只要您不同时使用这两个设备，就可以在与调制解调器相同的中断上运行图像采集卡。用户在系统启动时加载特殊设备的模块是很常见的，即使该设备很少使用。数据采集​​小工具可能使用与第二个串行端口相同的中断。虽然在数据采集过程中避免连接到 Internet 服务提供商 (ISP) 并不难，但为了使用调制解调器而被迫卸载模块确实令人不愉快。

调用 request_irq 的正确位置是在设备首次打开时，在指示硬件生成中断之前。调用 free_irq 的地方是最后一次关闭设备时，在硬件被告知不要再中断处理器之后。此技术的缺点是您需要保留每个设备的打开计数，以便您知道何时可以禁用中断。

尽管有这样的讨论，但 Short 在加载时请求其中断线。这样做是为了让您可以运行测试程序，而无需运行额外的进程来保持设备打开。因此，short 从其初始化函数 (short_init) 中请求中断，而不是像真正的设备驱动程序那样在 Short_open 中请求中断。

以下代码请求的中断是short_irq。变量的实际分配（即，确定使用哪个 IRQ）稍后显示，因为它与当前讨论无关。Short_base 是正在使用的并行接口的基 I/O 地址；写入接口的寄存器2以启用中断报告。
```c
if (short_irq >= 0) {
    result = request_irq(short_irq, short_interrupt,
            SA_INTERRUPT, "short", NULL);
   if (result) {
        printk(KERN_INFO "short: can't get assigned irq %i\n",
                short_irq);
        short_irq = -1;
    }
    else { /* actually enable it -- assume this *is* a parallel port */
        outb(0x10,short_base+2);
    }
}
```
代码显示，正在安装的处理程序是一个快速处理程序（SA_INTERRUPT），不支持中断共享（缺少SA_SHIRQ），并且不会对系统熵产生影响（也缺少SA_SAMPLE_RANDOM）。然后，outb 调用启用并行端口的中断报告。

无论如何，i386 和 x86_64 架构定义了一个用于查询中断线可用性的函数：
```c
int can_request_irq(unsigned int irq, unsigned long flags);
```
如果尝试分配给定中断成功，则该函数返回一个非零值。但请注意，在调用 can_request_irq 和 request_irq 之间，事情总是可能发生变化。

### 10.2.1. /proc 接口
